Lecture summaries - LEIC41D
===========================
:toc: auto

Lecture 1 - 2025-02-18 - 3h
---------------------------
* Course introduction
    ** link:https://isel.pt/sites/default/files/FUC_202425_1637.pdf[_Ficha de Unidade Curricular_].
    ** Goals
    ** Programme
        *** 16 weeks, including one week without lectures and some national holidays.
        *** See link:calendar.adoc[Calendar].
    ** Evaluation
        *** See link:course-evaluation.adoc[Course evaluation].
    ** Resources
        *** See link:resources.adoc[Resources].
    ** Tooling
        *** See link:tools.adoc[Tools].

* Introduction to concurrent programming and its challenges
    ** A motivating example - a TCP server
        *** Handling a single client at a time.
        *** Handling multiple clients simultaneously.
    ** Thread creation in the JVM.
        *** Available mechanisms.
        *** Consequences and hazards.
    ** Threading hazards.
        *** E.g. Lost increments.
        *** E.g. Lost insertions.

* Resources:
    ** link:https://github.com/isel-leic-pc/s2425v-li41d-li41n/blob/main/code/jvm/src/main/kotlin/pt/isel/pc/sketches/apps/MyFirstTcpServer.kt[`MyFirstTcpServer`] developed during the lecture.
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/tree/main/code/jvm/src/main/kotlin/org/pedrofelix/concurrency/course/apps/tcpserver[Different versions for the TCP server].
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/lecture-notes/a-motivating-example-tcp-server.adoc[A motivating example].
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/lecture-notes/threading-data-hazards.adoc[Threading data hazards].

Lecture 2 - 2025-02-21 - 1.5h
-----------------------------
* Continuing the introduction to concurrent programming and its challenges
    ** Data and multi-threading.
        *** Strategies for managing data in a multi-threaded program.
            **** No sharing - data confinement.
            **** Sharing of immutable data that was properly published.
            **** Sharing of mutable data with explicit coordination/synchronization mechanisms.
    ** Thread-safety definition.
        *** Examples.
        *** Non-composability of thread-safety.

* A model of how threads are implemented.
    ** Multiple processors using shared memory.
    ** Thread shared memory areas and thread exclusive memory areas.
    ** The concept of context and of context switch.
    ** Time multiplexing of M threads on N processors, when M is greater than N.

* Resources
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/lecture-notes/platform-threads-introduction.adoc[Platform threads].

Lecture 3 - 2025-02-25 - 3.0h
-----------------------------

* The _uthreads_ user-space multithreading system.
    ** Thread data structures - stack and descriptor.
    ** Suspending and resuming _uthreads_ - the `context_switch` function.
    ** Creating and terminating _uthreads_.
    ** The _uthreads_ system data structures, namely the ready queue.
    ** The _uthreads_ scheduling function.

* Exercises
    ** Setting up the development environment and making sure it is working correctly - see link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/exercises/environment-setup.adoc[Environment setup].
    ** _uthreads_ - see link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/exercises/uthreads.adoc[_uthreads_ exercises].

* Resources
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/lecture-notes/uthreads.adoc[_uthreads_ - User Mode Cooperative Threads].

Lecture 4 - 2025-02-28 - 1.5h
-----------------------------

* Adding control synchronization to the _uthreads_ system.
    ** Busy-waiting vs non-busy waiting.
    ** Adding a list of _joiners_ to each thread descriptor.
    ** Kernel-style (execution delegation).

* Adding I/O based control synchronization to the _uthreads_ system.
    ** Socket operations in the Linux Operating System.
    ** Non-blocking operation mode and the _epoll_ API.
    ** Changing the _uthreads_ system to support non-busy I/O control synchronization using _epoll_.

* Resources
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/lecture-notes/uthreads.adoc[_uthreads_ - User Mode Cooperative Threads].

Lecture 5 - 2025-03-07 - 1.5h
-----------------------------

* Data synchronization on mutable shared state
    ** Mutual exclusion and locks.
        ** The lock acquisition/lock and release/unlock protocol.
    ** Locks in the JVM.
        *** The link:https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/Lock.html[`Lock` interface] and the link:https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html[`ReentrantLock` class].
        *** The link:https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.concurrent/with-lock.html[`withLock` Kotlin function].
    ** Using the `class` mechanism to encapsulate the state protected by locks.
    ** Justification for the reentrancy support.
    ** Common errors when using locks.

* Resources
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/docs/lecture-notes/data-synchronization-jvm.adoc[Data synchronization in the JVM].
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/blob/main/code/jvm/src/test/kotlin/org/pedrofelix/concurrency/course/basics/IncorrectSynchronizationTests.kt[`IncorrectSynchronizationTests`].

Lecture 6 - 2025-03-11 - 3.0h
-----------------------------
* Control Synchronization.
    ** The concept of control synchronization and synchronizers.
    ** The _semaphore_ as an example of a synchronizer.
    ** Example: using semaphores to limit the number of connections being handled by the TCP server.
* Designing and implementing synchronizers using monitors.
    ** The monitor concept: a _lock_ plus one or more _conditions_.
    ** Interactions between the lock and the condition operations.
        *** The condition's _await_ operation and its relation with lock possession.
        *** The condition's _wait set_ and the _signal_ operation.
    ** Lock ownership between signaling and signaled thread (i.e. thread selected to leave the wait set).
    ** Example: an unary semaphore without fairness guarantees.
    ** Example: an unary semaphore with fairness guarantees.
    ** Using more than one condition to avoid broadcast signalling.
* JVM's thread interruption mechanism.

* Resources
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/tree/main/code/jvm/src/main/kotlin/org/pedrofelix/concurrency/course/sync[Synchronizer examples].
    ** link:https://github.com/isel-leic-pc/s2425v-li41d-li41n/tree/main/code/jvm/src/main/kotlin/pt/isel/pc/synchronizers[Lecture examples]

Lecture 7 - 2025-03-14 - 1.5h
-----------------------------
* JVM's thread interruption mechanism.
* Adding cancellation by timeout or interruption to a synchronizer.
    ** Concurrency between signalling, timeout, and interruption.
    ** JVM's guarantees (link:https://docs.oracle.com/javase/specs/jls/se21/html/jls-17.html#jls-17.2.4[Interactions of Waits, Notification, and Interruption]).

* Resources
    ** link:https://github.com/pmhsfelix/course-jvm-concurrency/tree/main/code/jvm/src/main/kotlin/org/pedrofelix/concurrency/course/sync[Synchronizer examples].
    ** link:https://github.com/isel-leic-pc/s2425v-li41d-li41n/tree/main/code/jvm/src/main/kotlin/pt/isel/pc/synchronizers[Lecture examples]

Lecture 8 - 2025-03-18 - 3.0h
-----------------------------
* Laboratory class to support the development of the first work assignment.
* Designing and implementing stress-tests for synchronizers and thread-safe classes.

Lecture 9 - 2025-03-21 - 1.5h
-----------------------------
* Continuing the study of monitor-based synchronizers - the _kernel-style_ technique to synchronizer design.
    ** Comparison with the _monitor-style_ technique.
    ** Implementation of an unary semaphore with fairness, using this technique.
    ** Implementation of a n-ary semaphore with fairness, using this technique.

Lecture 10 - 2025-03-25 - 3.0h
-----------------------------
* Continuing the study of monitor-based synchronizers
    ** A synchronous queue, designed using the _kernel-style_ technique.
    ** A simple thread pool.
* Laboratory to support the development of the first work assignment.

Lecture 11 - 2025-03-28 - 1.5h
-----------------------------
Laboratory class to support the development of the first work assignment.
